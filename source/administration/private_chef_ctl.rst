.. index::
  single: private-chef-ctl

=============================
private-chef-ctl
=============================

Private Chef has a command line utility, :command:`private-chef-ctl`, which is
used to perform the majority of the administrative activities associated with
Private Chef, such as managing services, configuring the servers, and watching
logs. 

:command:`private-chef-ctl` takes commands as arguments, and each
command is documented below. To execute a command:

.. code-block:: bash
  
  $ private-chef-ctl COMMAND

Where ``COMMAND`` is replaced with any of the commands below.

General Commands
----------------

.. index::
  pair: private-chef-ctl; help 

help
~~~~
  
Print a list of all the available private-chef-ctl commands.

.. index::
  pair: private-chef-ctl; reconfigure 

reconfigure
~~~~~~~~~~~

When changes are made to :file:`/etc/opscode/private-chef.rb`, the
private-chef-ctl reconfigure command is used to dynamically reconfigure the
server. Until this command is run, no changes have been made to the
configuration of any of the private chef services

.. index::
  pair: private-chef-ctl; show-config 

show-config
~~~~~~~~~~~

View the configuration that will be generated by :command:`private-chef-ctl reconfigure`. This
is useful in the early stages of a deployment, to ensure that everything will
be built properly prior to installation.

.. index::
  pair: private-chef-ctl; cleanse 

cleanse
~~~~~~~

The cleanse command re-sets a server to the state it was in before the first
run of :command:`private-chef-ctl reconfigure`. It will destroy all the data,
configuration files, and logs.

High Availability Commands
--------------------------

.. index::
  pair: private-chef-ctl; master-recover 

master-recover
~~~~~~~~~~~~~~

When running in a High Availability cluster, this command will force the
server to attempt to become the HA Master. Should usually be run in tandem
with :command:`private-chef-ctl backup-recover` on the backend peer, unless
it is no longer available.

.. index::
  pair: private-chef-ctl; backup-recover 

backup-recover
~~~~~~~~~~~~~~

The opposite of :command:`private-chef-ctl master-recover` - forces the server
to attempt to become the HA Backup. If run on both backend servers, will put
the cluster in a state where no server holds the DRBD resource.

Services Commands
-----------------

.. index::
  pair: private-chef-ctl; service-list 

service-list 
~~~~~~~~~~~~

Displays a list of all the private chef services. Those enabled on the machine are labled with an ``*``. 

.. index::
  pair: private-chef-ctl; status

status
~~~~~~

Shows the status of the private chef services. The output will vary based on the configuration of a given server.

This command can also be run for an individual service, rather than every service:

.. code-block:: bash

  $ private-chef-ctl opscode-solr status

Any service listed in :command:`private-chef-ctl service-list` can replace `opscode-solr` in the above. 

How to read a status line
:::::::::::::::::::::::::

Private Chef has a built in process supervisor, which makes sure all the required services are in the appropriate state at any given time. The supervisor starts two processes per service: 

* The service itself
* A process to capture the services logs

A typical status line for a running service on a non-high availability private chef server:

.. code-block:: bash

  run: opscode-solr: (pid 1486) 7819s; run: log: (pid 1485) 7819s

The first segment, ``run``, describes the state the supervisor is attempting to
keep the process in. Most commonly, this is either ``run`` (when the service
should be up and running) or ``down``, meaning the service should be stopped.

The second segment is the service name itself - in this case, ``opscode-solr``.

The third segment is the process ID of the running service process (``pid
14866``), followed by how long the process as been running in seconds
(``7819s``).

The fourth segment begins after the semicolon - the pattern then repeats for
the log process. Note that it is typical that the log process may have a longer
run time than the service it is managing: this is a side-effect of the fact
that the supervisor does not need to restart the log process to connect
supervised processes to the logger.

The status line for the same service, only stopped:

.. code-block:: bash

  down: opscode-solr: 3s, normally up; run: log: (pid 1485) 8526s

Not that the first segment has changed to ``down``, and the third segment is
now the time the service has been down, followed by the fact that the service
is ``normally up``. This means the supervisor would attmept to start this
service on reboot - given no other input, the service would "normally be up". 

Reading status on High Availability Servers
:::::::::::::::::::::::::::::::::::::::::::

On high availability backends, whether a service should be running or not is
controlled by our clustering service, ``keepalived``. When running
:command:`private-chef-ctl status` on these nodes, a few things change:

- On the backend node that is currently the "backup" server, it would be normal to see only the keepalived and nrpe processes as running.
- On the backend node that is currently the "master" server, it would be normal to see all the services running, but to have ``normally down`` appear in the third segment. This reflects the fact that, on reboot, this server would not attempt ot start these services: instead, it would allow ``keepalived`` to decide whether they should be running based on the cluster state.

A sample status line for a service on a High Availability "master":

.. code-block:: bash

  run: opscode-solr: (pid 25341) 239s, normally down; run: log: (pid 5700) 145308s

.. index::
  pair: private-chef-ctl; start 

start
~~~~~

Start all the enabled private chef services.

You can also start only a single service, rather than all services:

.. code-block:: bash 

  $ private-chef-ctl opscode-solr start

.. note::

  The private chef supervisor is configured to wait seven seconds for a service
  to respond to a command from the supervisor. If you see output that refrences
  a "timeout", it means that the signal has been sent to the process, but that
  it has yet to actually comply. In general, you can not worry about timed out
  processes, unless they are failing to respond to the signals at all - in
  which case you may need to escalate to using a command such as
  :command:`private-chef-ctl kill`.

.. index::
  pair: private-chef-ctl; stop

stop
~~~~

Stop all the enabled private chef services.

You can also stop only a single service:

.. code-block:: bash

  $ private-chef-ctl opscode-solr stop

.. index::
  pair: private-chef-ctl; restart

restart
~~~~~~~

Restart all the enabled private chef services.

You can also restart only a single service:

.. code-block:: bash

  $ private-chef-ctl opscode-solr restart

.. index::
  pair: private-chef-ctl; once 

once
~~~~

The supervisor is configured to restart any services that fail, unless we have
specifically asked them to change their state. This command changes this
behavior - it tells the supervisor that, should any service fail, do not
attempt to restart it ("Run it once"). This command is usually used when
troubleshooting configuration errors that cause a service to fail to start:
running :command:`private-chef-ctl once` followed by
:command:`private-chef-ctl status`, and looking for services in the ``down``
state will tell you what services are having trouble.

You can also tell only a specific service to run once:

.. code-block:: bash

  $ private-chef-ctl opscode-solr once

.. index::
  pair: private-chef-ctl; hup 

hup
~~~

Send a SIGHUP to all the services.

You can also hup only a specific service:

.. code-block:: bash

  $ private-chef-ctl opscode-solr hup

.. index::
  pair: private-chef-ctl; term 

term
~~~~

Send a SIGTERM to all the services.

You can also send term to only a specific service:

.. code-block:: bash

  $ private-chef-ctl opscode-solr term

.. index::
  pair: private-chef-ctl; int 

int
~~~

Send a SIGINT to all the services.

You can also send int to only a specific service:

.. code-block:: bash

  $ private-chef-ctl opscode-solr int

.. index::
  pair: private-chef-ctl; kill

kill
~~~~

Send a SIGKILL to all the services.

You can also send a kill to only a specific service:

.. code-block:: bash

  $ private-chef-ctl opscode-solr kill

.. index::
  pair: private-chef-ctl; tail

tail 
~~~~

Follow the Private Chef logs for all services.

You can also watch the logs of a specific service:

.. code-block:: bash

  $ private-chef-ctl opscode-solr tail


